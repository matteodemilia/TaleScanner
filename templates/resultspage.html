<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../static/results.css">
    <link rel="icon" href="/static/images/logo-small.png">
    <title>homepage</title>

</head>

<!-- This is the ENTIRE homepage space -->
<body>
    <!-- [ HEAD BAR ] -->
    <header class = "headbar">
        <div id ="homepageButton">
            <img src="/static/images/logo-small.png" alt="Logo-small" class="logo-small" > 
        </div>

        <div class = "title-banner">
            <img src="/static/images/title-text.png" alt="title-text" class="title-text-image">
        </div>

        <button class="about-btn" id = "about-btn">About</button>
    </header>

    <!-- Script that handles the headbar buttons -->
    <script type="text/javascript">
        document.getElementById("homepageButton").onclick = function () {
        
            location.href = "{{ url_for('index') }}";
        };
        
        document.getElementById("about-btn").onclick = function() {
        
            location.href ="/aboutpage"
        };
    </script> 


   <!--  <h3> RESULTS</h3>

    <p class="textInfo">Text:</p> <br> <br> <br> -->

    <!-- [ MAIN BODY ] *below head bar*-->
    <div class="container-results">
          
         
          <p class="textInput">{{ text }}</p>
        <!-- Footer of main dashboard
        <footer class = "footer"> 
            <img src="/static/images/logo-banner.png" alt="logo" width="15%" class = "logo-banner">
        </footer>
    -->
    </div> <!-- End of MAIN BODY -->

        <!-- start of analysis container-->
        <div class="container-analysis">
    
            <div class="results-display-output">
                <p class="results-title"> <strong> Results: </strong> </p>

                <!-- Total Words Result Output -->
                {% if 'totalWords' in selected_analysis %}
                <p><strong>Total Words:</strong> {{ totalwords.total }}</p>
                <div class = "details-accordian">
                    <input type = "checkbox" name = "accordian" id = "totalWords-details-input">
                    <label for = "totalWords-details-input"> details </label>
                    <div class = "details-content">
                        <p>
                            Word count is the most foundational process in natural language processing.
                            <br>
                            Each character of the text will be checked. A word is formed if the character is a letter, a number,  a dash, or other symbols (e.g. '@', '%', and '*') . 
                            It will stop forming a word when a white space is found. To maximize accuracy, please
                            ommit abnormal symbols from your text. For further information, refer to the 'About' page.
                            <br><br>
                            Some examples from your text:
                            <br>
                            First identified token: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">[{{ totalwords.firstword}}]</span>
                            <br>
                            Final identified token: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">[{{ totalwords.lastword }}]</span>
                            <br>
                            The word tokens are added to a list, and counted individually for the total: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">[{{ totalwords.total }}]</span>
                            <!--<br><br>
                            Confidence rating: VERY HIGH (>99%)-->
                        </p>
                    </div>
                </div>
                {% endif %}

                <!-- Total Unique Words Result Output -->
                {% if 'differentWords' in selected_analysis %}
                <p><strong>Different Words:</strong> {{ differentwords.count }}</p>
                <div class = "details-accordian">
                    <input type = "checkbox" name = "accordian" id = "differentWords-details-input">
                    <label for = "differentWords-details-input"> details </label>
                    <div class = "details-content">
                        <p>
                            Changes in unique word count can identify patterns of an increasing, or
                            decreasing vocabulary.
                            <br>
                            Similarly to total word count, the total uniqe word
                            count is determined through tokenization and list counting.
                            <br>
                            Based on your text, the unique words are:
                            <br><br>
                            Unique words: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">[{{ differentwords.list | join('] [') }}]</span>
                        </p>
                    </div>
                </div>
                {% endif %}

                <!-- Type Token Ratio Result Output -->
                {% if 'typeToken' in selected_analysis %}
                <p><strong>Type Token Ratio:</strong> {{ typetoken.typetokenratio }}</p>
                <div class = "details-accordian">
                    <input type = "checkbox" name = "accordian" id = "typeToken-details-input">
                    <label for = "typeToken-details-input"> details </label>
                    <div class = "details-content">
                        <p>
                            Type token ratio(TTR) helps determine variation. A higher TTR portrays a higher level of lexical variation. 
                            A lower TTR portrays a lower level of lexical variation.
                            <br>
                            TTR is determined by dividing the unique word count, by the
                            total word count. Thus, both the total word count and unique word count
                            functions are utilized. 
                            <br>
                            Based on your text:
                            <br>
                            [Unique word count: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ typetoken.differentwords }}</span>] / [Total word count: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ typetoken.totalwords }}</span>] = [TTR: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ typetoken.typetokenratio }}</span>]
                        </p>
                    </div>
                </div>
                {% endif %}

                <!-- Morphemes Result Output -->
                {% if 'morpheme' in selected_analysis %}
                <p><strong>Morphemes:</strong> {{ morphemes.count }}</p>
                <div class = "details-accordian">
                    <input type = "checkbox" name = "accordian" id = "morphemes-details-input">
                    <label for = "morphemes-details-input"> details </label>
                    <div class = "details-content">
                        <p>
                            To identify morphemes, one must break words down into smaller segments or
                            syllables, to identify meaning in the segments. To accomplish such a task
                            systematically, the text is tokenized and categorized based on tense, 
                            plurality, roots, special cases, and more. Because of this, error cases
                            in morpheme count is common, and should be used as a relative growth tool.
                            <br><br>       

                            Bound: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{morphemes.bound}}</span>
                            <br><br>
                            Free: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{morphemes.free}}</span>

                        </p>
                    </div>
                </div>
                {% endif %}

                <!-- Total Clauses Result Output -->
                {% if 'totalClauses' in selected_analysis %}
                <p><strong>Total Clauses:</strong> {{ totalclauses.numClauses }}</p>
                <div class = "details-accordian">
                    <input type = "checkbox" name = "accordian" id = "totalClauses-details-input">
                    <label for = "totalClauses-details-input"> details </label>
                    <div class = "details-content">
                        <p>
                            A clause is a group of words under a sentence in hierarchy, which contains both a
                            subject and a predicate. There are several types of clauses, and it can be difficult
                            to determine each type simultaneously in the same process. This tool uses generalized
                            patterns to help determine all types of clauses, but specializes in main clause identification. 
                            <br><br>
                            The number of clauses feature takes into account all kinds of clauses- independent, subordinate (dependent), and more specific types of subordinate clauses such as adjective, adverbial, and noun clauses.
                            <br><br>
                            The number of clauses is determined by tokenizing the input and iterates through each sentence and then the words (tokens). 
                            For each sentence, it finds the root token (usually the main verb). It also finds other verbs in the sentence as it may be part of the clause. 
                            Using these verbs, it finds the start and end indices of the clause in the sentence, which is accomplished by analyzing the dependency relationships and finding tokens that are related to the verbs. 
                            These clauses are then stored into a list.
                            <br><br>
                            <span style="color: red">WARNING:</span> 
                            The number of clauses may not be accurate, more commonly those with conjunctions that are in the middle of the sentences. 
                            We are also currently unable to extract each clause and display it accurately. 
                            <br><br>
                            Based on your text:
                            <br>
                            There are <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">[{{ totalclauses.numClauses}}]</span> total clauses.
                            <br>
                            <!--First clause: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">[{{ totalclauses.list[0] }}]</span> -->
                        </p>
                    </div>
                </div>
                {% endif %}

                <!-- Suboordinate Clauses Result Output -->
                {% if 'subordinateClauses' in selected_analysis %}
                <p><strong>Subordinate Clauses:</strong> {{ totalsubordinate.numSubordinate }}</p>
                <div class = "details-accordian">
                    <input type = "checkbox" name = "accordian" id = "subordinateClauses-details-input">
                    <label for = "subordinateClauses-details-input"> details </label>
                    <div class = "details-content">
                        <p>
                            Subordinate clauses are typically introduced with a conjuction, 
                            and is dependent on a main clause (often called dependent clauses).
                            The use of subordinate clauses can add fluidity and complexity to many texts. 
                            <br><br>
                            Tale Scanner determines subordinate clauses by tokenizing the input and interates through each sentence and then the words (tokens).
                            For each token, it checks whether it is a subordinating conjunction and also utilizes spacy's dependency tagging feature, 
                            which checks whether the token is marked as relcl (relative clause), advcl (adverbial clause), and ccomp (casual complement). 
                            If these are found, the token is stored in a conjunction list.
                            <br><br>
                            <span style="color: red">WARNING:</span> 
                            The number of subordinate clauses may not be accurate, more commonly those with conjunctions that are in the middle of the sentences.
                            We are also currently unable to extract each subordinate clause and display it accurately, but can display the conjunctions that were found.
                            <br><br>
                            Based on your text:
                            <br>
                            There are <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">[{{ totalsubordinate.numSubordinate}}]</span>subordinate clauses.
                            <br>
                            {% if totalsubordinate.numSubordinate > 0 %}
                                List of conjunctions: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">[{{ totalsubordinate.list | join('] [') }}]</span>
                            {% endif %}
                        </p>
                    </div>
                </div>
                {% endif %}

                <!-- Syntactic Subordination Result Output -->
                {% if 'syntacticSubordination' in selected_analysis %}
                <p><strong>Syntactic Subordination Index:</strong> {{ syntacticsubordination.index }}</p>
                <div class = "details-accordian">
                    <input type = "checkbox" name = "accordian" id = "syntacticSubordination-details-input">
                    <label for = "syntacticSubordination-details-input"> details </label>
                    <div class = "details-content">
                        <p>
                            Syntactic subordination index is determined by dividing the subordinate clauses, by the
                            total number of clauses. Thus, both the subordinate clauses count and number of clauses count
                            functions are utilized. 
                            <br>
                            Based on your text:
                            <br>
                            [Subordinate clause count: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ syntacticsubordination.subordinateClauses }}</span>] / [Total clause count: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ syntacticsubordination.totalClauses }}</span>] = [Syntactic subordination index: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ syntacticsubordination.index }}</span>]
                        </p>
                    </div>
                </div>
                {% endif %}

                <!-- Verb Errors Result Output -->
                {% if 'verbErr' in selected_analysis %}
                <p><strong>Verb Errors:</strong> {{ verberrors.count }}</p>
                <div class = "details-accordian">
                    <input type = "checkbox" name = "accordian" id = "verbErrors-details-input">
                    <label for = "verbErrors-details-input"> details </label>
                    <div class = "details-content">
                        <p>
                            The found verb errors are listed below.
                            <br><br>
                            Confidence rating: VERY HIGH (>99%)
                            <br><br>
                            Sentences with verb errors: <br> 
                            {% for index in range(verberrors.list|length) %}
                                <li>{{ verberrors.list[index] }}</li>
                                <p>Bad Verb: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ verberrors.bad[index] }}</span></p>
                            {% endfor %}
                                <!-- {{ verberrors.list | join('') }} -->
                        </p>
                    </div>
                </div>
                {% endif %}

                <!-- Verb Error Ratio Result Output -->
                {% if 'verbClauses' in selected_analysis %}
                <p><strong>Verb Error Ratio</strong> {{ verbclauses.verbClauses }}</p>
                <div class = "details-accordian">
                    <input type = "checkbox" name = "accordian" id = "verbClauses-details-input">
                    <label for = "verbClauses-details-input"> details </label>
                    <div class = "details-content">
                        <p>
                            The verb error ratio is the total number of verb errors divided by the
                            total number of clauses. Thus, both the verb error count and total clause count
                            functions are utilized.
                            <br>
                            Based on your text:
                            <br>
                            [Verb error count: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ verbclauses.verbErrors }}</span>] / [Total clause count: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ verbclauses.totalClauses }}</span>] = [Verb error ratio: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ verbclauses.verbClauses }}</span>]
                            
                        </p>
                    </div>
                </div>
                {% endif %}

                <!-- Words Per Clause Result Output -->
                {% if 'wordsClauses' in selected_analysis %}
                <p><strong>Words Per Clause:</strong> {{ wordsperclauses.wordsPerClause }}</p>
                <div class = "details-accordian">
                    <input type = "checkbox" name = "accordian" id = "wordsClauses-details-input">
                    <label for = "wordsClauses-details-input"> details </label>
                    <div class = "details-content">
                        <p>
                            Words per clause is determined as an average of the total word count per clause.
                            Thus, both the total word count and total clauses functions are utilized.
                            <br> 
                            Based on your text:
                            <br>
                            [Total word count: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ wordsperclauses.totalWords }}</span>] / [Total clause count: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ wordsperclauses.totalClauses }}</span>] = [Words per clause: <span style="font-weight: bold; color: #004e8d; font-family: 'Courier New', Courier, monospace;">{{ wordsperclauses.wordsPerClause }}</span>]
                           
                        </p>
                    </div>
                </div>
                {% endif %}

            </div>

           
        </div>
        <!-- end of analysis container-->
    </body>
</html>